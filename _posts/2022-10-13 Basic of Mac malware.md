The goal of this section is to help you pick apart MacOs malware to get better insight into how it built.

Once the malware has infected the system, its goal is to persist on the computer, which can be done in multiple way as a startup item in launch item or login item, etc.\
If you want an list of possible places malware can persists I recommend you go to the mac forensics section. Here I list the possible method you can get persistance on a MacOS system.

Just like with every other system there exists two method of analyzing MacOS statically or dynamically.\
Before we start analyzing MacOS binaries we need to look into how they are structure.

### Native file

#### Mach Object

Mach object file format (Mach-O) - The native executable format for binaries in OS X. At a low level Mach-o files consists of three parts or regions, the header, load commands and data.

**The header**

Will identifies the files as a mach-o file, in there is also contain some basic information about the file such as the target architecture and flag for how rest of the data should be processed. Of note the filetype parameter will describe the type of file it is, there exist serveral type of like (0x2:standard exe, 0x6:dll dylib, 0x8: bundle) tools such as otool with -hv or machoview allow you to view the header of these files.

```
struct mach_header_64 {
uint32_t    magic;          # mach magic number identifier
cpu_tpe_t   cputype;        # cpu specifier
cpu_subtube_t   cpusubtype; # machine specifier
uint32_t    filetype;       # type of file
uint32_t    ncmds;          # number of load commands
uint32_t    sizeofcmds;     # the size of all the load command
uint32_t    flags;          # flags
uint32_t    reserved;       # reserved
}
```

**Load command**

After the header section is the load commands which tells how to load and layout the binary in memory, using the otool with -l flag will display the command section. Load command begin with a load\_command structure which have two variables, cmd that tell the type of command cmdsize that say what the size of the command is.

```
struct load_command {
uint_32_t   cmd;        # type of load command
uint_32_t   cmdsize;    # total size of commands in bytes
}
```

Once the binary is loaded into memory by the dyld, the execution begins at the entry point, the way dyld locate the entry point is via the LC\_main load command. The most important function in LC\_MAIN is the entryoff which contain the offset of the binary entry point, at load time dyld will add the value to the in-memory base of the binary and then jump to the instruction to kickoff the execution for the bin.

```
struct entry_point_command {
uint_32_t   cmd;        # LC_MAIN only used in MH_EXECUTE filetypes
uint_32_t   cmdsize;    # total size of commands in bytes
uint64_t entryoff;      # file TEXT offset of main
uint64_t stacksize;     # if not zero, initial stack size
}
```

entry\_point\_command structure another is LC\_LOAD\_DYLIB which describes which dyld to load and link, from malware analysis point of view can provide insight into the capabilities of malware, for example a bin that contain a that reference DiskArbitration library may be interested in monitoring USB drivers. Serveral key segement when analysing mach-o bin.

* \_TEXT - contain executable code and data that is read-only.
* \_DATA - data that is writable.
* \_LINKEDIT - Information for the linker (dyld) such as symbol, string and relocation tables entries.

**DATA**

Consist of the binary code, this data is organized into segments code or data each segment contains one or more section, different type of code and data goes into each section

* \_TEXT : executable code and data that is read-only
  * \_text - complied bin code
  * \_const - constant data
  * \_cstring \_ string constats
* \_DATA : contains writable data
  * \_data - global var
  * \_bss - static variables

#### Bundle

Bundles are folder container which have all the files necessary for an application to run, to view the content on a bundle and tool called Apparency can be used to view inside the file.\
Are self contain application files with contains everything needed to run the application. If the file is transfer to a Windows machine it would appear as a folder contain multiple files.

**Subfolder**

* \_codesignatur - contains code-signing information about the app
* MacOS - Application binary
* Resource - UI elements of the application
* info.plist - The main configuration file

### Scripts

Applescript is macOS scripting language, of the problem when analysing is that they can be set to Run-only mode making it difficult to analysis, one way is to use an tool called AppleScript disassembler, will try to decompile the script into more human-readable, by taking the output from the disassembler and running it through aevt\_decompile will make the code even more readable.

### Disassembling & decompiling

The majority of mach-o is written in object-c, which retain their class when compiled into bin, include the classes, methods and variables. Tools such as class-dump can be used to extract the information of examination.

Packer - It quite common for bin to be packed code e.g. python coded that have been packed into a bin file using Platypus, there exist many type of packers.

Platypus - bin that have been packed with platypus it code that viewed inside the application directory contents/resources/ looking for a file named script. If this file exist it most likely a application created using platypus.

PyInstaller - identified by look for the embedded string Py-SetPythonHome, The compiled coded can be extracted from the binary by using pyinstxtracotor, to decompile the compiled python by using a decompiler such as decompiler.com

Electron - identified by javascript files can be found inside /contents/resources dir, achieved in .asar files