The goal of this section is to help you analyze MacOS malware to gain better insight into how it is built.

Once the malware has infected the system, its goal is to persist on the computer, which can be done in multiple ways such as a startup item, launch item, or login item, etc.\
For a list of possible places where malware can persist, I recommend visiting the Mac forensics section, which provides an overview of potential methods for gaining persistence on a MacOS system.

Just like with every other system, there are two methods for analyzing MacOS binaries: statically or dynamically.\
Before we start analyzing MacOS binaries, we need to understand their structure.

### Native file

#### Mach Object

Mach object file format (Mach-O) is the native executable format for binaries in OS X. At a low level, Mach-O files consist of three parts or regions: the header, load commands, and data.

**The header**

The header identifies the file as a Mach-O file and contains some basic information about the file, such as the target architecture and flags for processing the rest of the data. The filetype parameter describes the type of file (e.g., 0x2: standard exe, 0x6: dylib, 0x8: bundle). Tools like otool with the -hv flag or MachOView allow you to view the header of these files.

```
struct mach_header_64 {
uint32_t    magic;          # mach magic number identifier
cpu_tpe_t   cputype;        # cpu specifier
cpu_subtube_t   cpusubtype; # machine specifier
uint32_t    filetype;       # type of file
uint32_t    ncmds;          # number of load commands
uint32_t    sizeofcmds;     # the size of all the load commands
uint32_t    flags;          # flags
uint32_t    reserved;       # reserved
}
```

**Load command**

After the header section, load commands specify how to load and lay out the binary in memory. Using otool with the -l flag displays the command section. Load commands begin with a load_command structure containing two variables: cmd, which indicates the type of command, and cmdsize, which specifies the command's size.

```
struct load_command {
uint_32_t   cmd;        # type of load command
uint_32_t   cmdsize;    # total size of commands in bytes
}
```

Once the binary is loaded into memory by the dyld, execution begins at the entry point. Dyld locates the entry point via the LC_MAIN load command. The most important function in LC_MAIN is entryoff, which contains the binary entry point's offset. At load time, dyld adds this value to the binary's in-memory base and then jumps to the instruction to kick off the execution.

```
struct entry_point_command {
uint_32_t   cmd;        # LC_MAIN only used in MH_EXECUTE filetypes
uint_32_t   cmdsize;    # total size of commands in bytes
uint64_t entryoff;      # file TEXT offset of main
uint64_t stacksize;     # if not zero, initial stack size
}
```

Entry_point_command structure includes another command, LC_LOAD_DYLIB, which describes which dylibs to load and link. From a malware analysis perspective, this can provide insight into the malware's capabilities. For example, a binary that contains a reference to the DiskArbitration library may be interested in monitoring USB drives. Several key segments are analyzed in Mach-O binaries.

* _TEXT - contains executable code and read-only data.
* _DATA - contains writable data.
* _LINKEDIT - contains information for the linker (dyld) such as symbol, string, and relocation table entries.

**DATA**

Data consists of the binary code, organized into segments of code or data. Each segment contains one or more sections, with different types of code and data allocated to each section.

* _TEXT: executable code and read-only data
  * _text - compiled binary code
  * _const - constant data
  * _cstring - string constants
* _DATA: writable data
  * _data - global variables
  * _bss - static variables

#### Bundle

Bundles are folder containers that include all the files necessary for an application to run. To view the contents of a bundle, a tool called Apparency can be used to look inside the file. Bundles are self-contained application files containing everything needed to run the application. If the file is transferred to a Windows machine, it appears as a folder containing multiple files.

**Subfolder**

* _codesignatur - contains code-signing information about the app
* MacOS - Application binary
* Resources - UI elements of the application
* info.plist - The main configuration file

### Scripts

AppleScript is macOS's scripting language. One problem when analyzing AppleScript is that it can be set to Run-only mode, making it difficult to analyze. One approach is to use a tool called AppleScript Disassembler, which attempts to decompile the script into a more human-readable form. By taking the output from the disassembler and running it through aevt_decompile, the code becomes even more readable.

### Disassembling & Decompiling

The majority of Mach-O binaries are written in Objective-C, which retains their class structure when compiled into binaries. This includes classes, methods, and variables. Tools such as class-dump can be used to extract this information for examination.

**Packers** - It is quite common for binaries to be packed code, e.g., Python code that has been packed into a binary file using Platypus. Many types of packers exist.

**Platypus** - Binaries that have been packed with Platypus can have their code viewed inside the application directory at contents/resources/ by looking for a file named "script." If this file exists, it is likely an application created using Platypus.

**PyInstaller** - Identified by looking for the embedded string Py-SetPythonHome. The compiled code can be extracted from the binary using pyinstxtractor. To decompile the compiled Python, use a decompiler such as decompiler.com.

**Electron** - Identified by JavaScript files found inside /contents/resources directory, archived in .asar files.